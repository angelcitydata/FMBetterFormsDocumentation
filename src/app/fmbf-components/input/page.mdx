export const metadata = {
  title: 'Input Component',
  description:
    'A comprehensive input component for FM BetterForms with advanced formatting capabilities including currency, phone numbers, dates, SSN, and intelligent number handling.',
}

# Input Component

The Input component is an advanced form control that provides intelligent formatting for various data types including currency, phone numbers, dates, SSNs, and numbers. It features real-time formatting, automatic input mode detection, and seamless integration with the FM BetterForms model system. {{ className: 'lead' }}

This component automatically formats user input based on the specified format type, handles value parsing and storage, maintains proper cursor positioning during formatting, and provides extensive customization options.

---

## Component Properties

### Display & Layout Properties

<Properties>
  <Property name="label" type="string">
    The label text displayed above the input field. Shows with a red asterisk if the field is required.
  </Property>
  <Property name="placeholder" type="string">
    Placeholder text displayed when the input is empty.
  </Property>
  <Property name="fullWidth" type="boolean">
    When true, the input takes the full width of its container. When false, uses minimum width.
  </Property>
  <Property name="size" type="string">
    Controls the text size of the input. Options: "sm" (text-sm), "md" (text-sm), "lg" (text-base). Default is "md".
  </Property>
  <Property name="icon" type="string">
    Font Awesome icon class displayed on the left side of the input (e.g., "fa-user").
  </Property>
  <Property name="iconRight" type="string">
    Font Awesome icon class displayed on the right side of the input.
  </Property>
  <Property name="prefix" type="string">
    Text displayed before the input value (e.g., "$" for currency).
  </Property>
  <Property name="suffix" type="string">
    Text displayed after the input value (e.g., "%" for percentages).
  </Property>
</Properties>

### Input Behavior Properties

<Properties>
  <Property name="type" type="string">
    HTML input type that controls basic browser behavior. **Supported values:**
    - `"text"` (default) - Standard text input
    - `"email"` - Email input with validation
    - `"password"` - Password input (masked text)
    - `"number"` - Numeric input with browser controls
    - `"tel"` - Telephone number input
    - `"url"` - URL input with validation
    - `"search"` - Search input
    - `"date"` - Date picker input
    - `"time"` - Time picker input
    - `"datetime-local"` - Date and time picker
    
    **Note:** The type property works independently of format - formats handle display and parsing while type controls browser behavior.
  </Property>
  <Property name="format" type="string">
    Special formatting mode that adds intelligent parsing and display formatting. **Supported values:**
    - `"currency"` - Currency formatting (e.g., 1,234.56) with decimal support
    - `"number"` - Number formatting with commas (e.g., 1,234.56) 
    - `"percent"` - Percentage formatting (same as number but semantic difference)
    - `"integer"` - Integer-only formatting with commas (e.g., 1,234)
    - `"phone"` - Phone number formatting (e.g., (555) 123-4567)
    - `"date"` - Date formatting (MM/DD/YYYY) with ISO storage support
    - `"ssn"` - Social Security Number formatting (e.g., 123-45-6789)
    - `""` or `undefined` (default) - No special formatting, standard text input
    
    Each format automatically sets appropriate `inputmode` for mobile keyboards and handles real-time formatting during typing.
  </Property>
  <Property name="allowNegative" type="boolean">
    When true, allows negative values for numeric formats (currency, number, percent, integer). Default is false.
  </Property>
  <Property name="maxLength" type="string">
    Maximum number of characters allowed in the input.
  </Property>
  <Property name="required" type="boolean">
    When true, displays a red asterisk next to the label and adds HTML5 required validation.
  </Property>
  <Property name="readOnly" type="boolean">
    When true, the input cannot be edited but can be focused and its value copied.
  </Property>
  <Property name="isDisabled" type="boolean">
    When true, the input is disabled and cannot be interacted with. Applies opacity styling.
  </Property>
  <Property name="storeAsNumber" type="boolean">
    When true, numeric formats store values as numbers in the model. When false, stores as strings. Default is false. Applies to currency, number, percent, and integer formats.
  </Property>
</Properties>

### Format-Specific Properties

<Properties>
  <Property name="phoneMaxDigits" type="number">
    Maximum number of digits allowed for phone format. Default is 10.
  </Property>
  <Property name="ssnMaxDigits" type="number">
    Maximum number of digits allowed for SSN format. Default is 9.
  </Property>
  <Property name="storeMasked" type="boolean">
    When true, stores the formatted/masked value for phone and SSN formats instead of just digits. Default is false.
  </Property>
  <Property name="dateStoreISO" type="boolean">
    When true, stores valid dates in ISO format (YYYY-MM-DD) for date format. When false, stores raw digits. Default is true.
  </Property>
</Properties>

### Data Binding Properties

<Properties>
  <Property name="modelKey" type="string">
    The key path in the form model where the input value is stored. Supports nested paths like "user.profile.name". Default is "inputValue".
  </Property>
  <Property name="windowIndex" type="number">
    Index of the window in the BetterForms window stack. Used for multi-window applications. Default is 0.
  </Property>
</Properties>

### Action Properties

<Properties>
  <Property name="inputAction" type="string">
    Named action to trigger on every input change. Receives the current value and event object.
  </Property>
  <Property name="namedAction" type="string">
    Named action to trigger when Enter key is pressed in the input field.
  </Property>
  <Property name="onInput" type="string">
    Legacy property for input event handling (use inputAction instead).
  </Property>
</Properties>

### Validation & Feedback Properties

<Properties>
  <Property name="errorMessage" type="string">
    Error message to display below the input. When present, applies error styling (red border and text).
  </Property>
  <Property name="successMessage" type="string">
    Success message to display below the input. When present and no error exists, applies success styling (green border and text).
  </Property>
</Properties>

---

## Type vs Format: Understanding the Interaction

The `type` and `format` properties work together in a layered approach, but it's crucial to understand how they interact to avoid conflicts:

### How They Work Together

1. **`type`** provides the foundation HTML input behavior (text, email, password, number, etc.)
2. **`format`** adds specialized business logic and formatting on top of the base type
3. **When conflicts arise, `format` takes precedence** and may override the `type`

### Currency Format Override Behavior

When you set `format: "currency"`, the component automatically:
- **Overrides `type` to "text"** regardless of what you specified
- **Sets `inputmode="decimal"`** for mobile numeric keypads
- **Enables special currency logic** (formatting, parsing, validation)

```json title="Currency Override Example"
{
  "type": "number",        // This gets ignored!
  "format": "currency",    // This forces type="text"
  "label": "Price"
  // Result: HTML input will be type="text" with inputmode="decimal"
}
```

### Best Practices to Avoid Conflicts

**‚úÖ Do:**
- Use `type: "text"` with `format: "currency"` (explicit and clear)
- Use `type: "email"` without any format (standard email validation)
- Use `type: "password"` without any format (standard password input)
- Use `type: "text"` without format for general text input

**‚ùå Don't:**
- Use `type: "number"` with `format: "currency"` (creates confusion - format will override)
- Mix incompatible combinations that fight each other

**üí° Future-Proof Approach:**
When using any `format`, set `type: "text"` explicitly to make the intention clear and avoid surprises when new formats are added.

---

## Usage Examples

The Input component can be used in two ways: as JSON configuration objects or as HTML `<bfcomp>` elements. Both approaches provide the same functionality.

### Basic Text Input

<CodeGroup>
```html title="HTML Component"
<bfcomp name="Input" 
        modelKey="contact.nameFirst" 
        label="First Name" 
        placeholder="First Name" 
        fullWidth="true">
</bfcomp>
```

```json title="JSON Configuration"
{
  "label": "Full Name",
  "placeholder": "Enter your full name",
  "modelKey": "user.fullName",
  "required": true,
  "maxLength": "50"
}
```
</CodeGroup>

### Currency Input

<CodeGroup>
```html title="HTML Component"
<bfcomp name="Input" 
        modelKey="case.totalAmount" 
        label="Total Amount" 
        prefix="$" 
        format="currency">
</bfcomp>
```

```json title="JSON Configuration"
{
  "label": "Total Amount",
  "type": "text",
  "format": "currency",
  "prefix": "$",
  "modelKey": "case.totalAmount",
  "storeAsNumber": true,
  "allowNegative": true
}
```
</CodeGroup>

### Phone Number Input

<CodeGroup>
```html title="HTML Component"
<bfcomp name="Input" 
        modelKey="contact.phone" 
        label="Phone" 
        type="tel" 
        format="phone" 
        placeholder="Phone" 
        fullWidth="true">
</bfcomp>
```

```json title="JSON Configuration"
{
  "label": "Phone Number",
  "type": "tel",
  "format": "phone",
  "modelKey": "contact.phone",
  "phoneMaxDigits": 10,
  "storeMasked": false,
  "placeholder": "Phone",
  "fullWidth": true
}
```
</CodeGroup>

### Date Input

<CodeGroup>
```html title="HTML Component"
<bfcomp name="Input" 
        modelKey="contact.dateOfBirth" 
        label="DoB" 
        type="date" 
        format="date" 
        placeholder="Date of Birth" 
        fullWidth="true">
</bfcomp>
```

```json title="JSON Configuration"
{
  "label": "Date of Birth",
  "type": "date",
  "format": "date",
  "modelKey": "contact.dateOfBirth",
  "dateStoreISO": true,
  "placeholder": "Date of Birth",
  "fullWidth": true
}
```
</CodeGroup>

### SSN Input

<CodeGroup>
```html title="HTML Component"
<bfcomp name="Input" 
        modelKey="contact.ssn" 
        label="SSN" 
        placeholder="SSN" 
        format="ssn" 
        fullWidth="true">
</bfcomp>
```

```json title="JSON Configuration"
{
  "label": "Social Security Number",
  "type": "text",
  "format": "ssn",
  "modelKey": "contact.ssn",
  "ssnMaxDigits": 9,
  "storeMasked": false,
  "placeholder": "SSN",
  "fullWidth": true
}
```
</CodeGroup>

### Integer Input

<CodeGroup>
```html title="HTML Component"
<bfcomp name="Input" 
        modelKey="order.quantity" 
        label="Quantity" 
        format="integer" 
        placeholder="0" 
        storeAsNumber="true">
</bfcomp>
```

```json title="JSON Configuration"
{
  "label": "Quantity",
  "type": "text",
  "format": "integer",
  "modelKey": "order.quantity",
  "storeAsNumber": true,
  "allowNegative": false,
  "placeholder": "0"
}
```
</CodeGroup>

### Email Input

<CodeGroup>
```html title="HTML Component"
<bfcomp name="Input" 
        modelKey="contact.email" 
        label="Email Address" 
        type="email" 
        placeholder="Enter your email" 
        required="true" 
        fullWidth="true">
</bfcomp>
```

```json title="JSON Configuration"
{
  "label": "Email Address",
  "type": "email",
  "modelKey": "contact.email",
  "placeholder": "Enter your email",
  "required": true,
  "fullWidth": true
}
```
</CodeGroup>

### Input with Icons and Actions

<CodeGroup>
```html title="HTML Component"
<bfcomp name="Input" 
        modelKey="searchQuery" 
        label="Search Query" 
        placeholder="Type to search..." 
        icon="fa-search" 
        iconRight="fa-times" 
        inputAction="performSearch" 
        namedAction="submitSearch">
</bfcomp>
```

```json title="JSON Configuration"
{
  "label": "Search Query",
  "placeholder": "Type to search...",
  "icon": "fa-search",
  "iconRight": "fa-times",
  "modelKey": "searchQuery",
  "inputAction": "performSearch",
  "namedAction": "submitSearch"
}
```
</CodeGroup>

### Dynamic Search with Filter Action

<CodeGroup>
```html title="HTML Component"
<bfcomp name="Input" 
        modelKey="query" 
        :placeholder="`Search ${model.contactList.length} contacts`" 
        icon="fa-magnifying-glass" 
        fullWidth="true" 
        inputAction="filter">
</bfcomp>
```

```json title="JSON Configuration"
{
  "modelKey": "query",
  "placeholder": "Search contacts...",
  "icon": "fa-magnifying-glass",
  "fullWidth": true,
  "inputAction": "filter"
}
```
</CodeGroup>

### Password Input

<CodeGroup>
```html title="HTML Component"
<bfcomp name="Input" 
        modelKey="user.password" 
        label="Password" 
        type="password" 
        placeholder="Enter your password" 
        required="true" 
        iconRight="fa-eye" 
        fullWidth="true">
</bfcomp>
```

```json title="JSON Configuration"
{
  "label": "Password",
  "type": "password",
  "modelKey": "user.password",
  "placeholder": "Enter your password",
  "required": true,
  "iconRight": "fa-eye",
  "fullWidth": true
}
```
</CodeGroup>

### Number/Percent Input

<CodeGroup>
```html title="HTML Component"
<bfcomp name="Input" 
        modelKey="tax.rate" 
        label="Tax Rate" 
        format="percent" 
        suffix="%" 
        storeAsNumber="true" 
        placeholder="0.00">
</bfcomp>
```

```json title="JSON Configuration"
{
  "label": "Tax Rate",
  "type": "text",
  "format": "percent",
  "suffix": "%",
  "modelKey": "tax.rate",
  "storeAsNumber": true,
  "allowNegative": false,
  "placeholder": "0.00"
}
```
</CodeGroup>

---

## Input Styling

The Input component renders with a consistent, modern appearance that adapts to your form's theme. Here's what you can expect from the component styling:

### Visual Structure

The component renders as a structured input container with the following visual hierarchy:

- **Label**: Positioned above the input field with appropriate spacing
- **Input Container**: A bordered input box with rounded corners and proper padding
- **Prefix/Suffix**: Styled text elements positioned inside the input container
- **Icons**: Font Awesome icons positioned appropriately within the input
- **Placeholder**: Subtle text that appears when the input is empty

### Default Appearance

```html
<!-- Renders as a clean, bordered input with label -->
<div class="input-group">
  <label>First Name</label>
  <div class="input-container">
    <input type="text" placeholder="First Name" />
  </div>
</div>
```

### Styled Variations

**With Prefix** (e.g., Currency Input):
```html
<!-- $ symbol appears inside the input on the left -->
<div class="input-container">
  <span class="prefix">$</span>
  <input type="text" />
</div>
```

**With Suffix** (e.g., Percent Input):
```html
<!-- % symbol appears inside the input on the right -->
<div class="input-container">
  <input type="text" />
  <span class="suffix">%</span>
</div>
```

**With Icons** (e.g., Phone Input):
```html
<!-- Font Awesome icon appears inside the input -->
<div class="input-container">
  <i class="fa-regular fa-phone"></i>
  <input type="tel" />
</div>
```

### Responsive Behavior

- **Full Width**: When `fullWidth="true"`, the input expands to fill its container
- **Mobile Optimized**: Inputs automatically show appropriate mobile keyboards based on format
- **Focus States**: Clear visual feedback when the input receives focus
- **Error States**: Validation errors are displayed with appropriate styling

### Theme Integration

The component styling integrates seamlessly with your form's overall design system and supports consistent spacing, colors, and typography throughout your application.

---

## Format Behavior Details

### Input Mode Mapping

The component automatically sets the appropriate `inputmode` attribute based on format for optimal mobile keyboard experience:

- **`currency, number, percent`** ‚Üí `inputmode="decimal"` (numeric keypad with decimal)
- **`integer, date, ssn`** ‚Üí `inputmode="numeric"` (numeric keypad only)
- **`phone`** ‚Üí `inputmode="tel"` (telephone keypad)
- **All others** ‚Üí No inputmode (standard keyboard)

### Real-Time Formatting

All formats provide real-time formatting as the user types:
- **Maintains cursor position** during formatting changes
- **Handles special keys** (decimal point, negative sign) intelligently  
- **Prevents invalid characters** from being entered
- **Provides immediate visual feedback**

### Storage Options

Different formats offer different storage options:
- **Numeric formats** (`currency`, `number`, `percent`, `integer`): Can store as numbers or formatted strings
- **Masked formats** (`phone`, `ssn`): Can store masked display value or raw digits
- **Date format**: Can store as ISO date string or raw digits

---

## Component Schema

The complete component schema for the Input component. Copy and paste this code into the Component Schema section of your BetterForms app.

### Complete Schema

<CodeGroup>
```json title="Component Schema"
{
    "allowNegative": false,
    "currencyLiveFormat": true,
    "errorMessage": "",
    "format": "",
    "fullWidth": true,
    "html": "<div\n  :class=\"[\n    (function(v){\n      v = (v ?? '') + ''; v = v.toLowerCase();\n      return (v==='true'||v==='1'||v==='on'||v==='yes'||schema.fullWidth===true) ? 'w-full' : 'w-fit';\n    })(schema.fullWidth)\n  ].join(' ')\"\n>\n  <label v-if=\"schema.label\" class=\"mb-1 block text-sm font-medium text-foreground\">\n    {{ schema.label }}<span v-if=\"schema.required\" aria-hidden=\"true\" class=\"text-destructive\"> *</span>\n  </label>\n\n  <div\n    class=\"flex items-center gap-2 rounded-md border px-3 py-2 bg-background\"\ :class=\"[\n      'border-input',\n      'focus-within:ring-2 focus-within:ring-ring',\n      (schema.errorMessage ? 'border-destructive focus-within:ring-destructive' : ''),\n      (!schema.errorMessage && schema.successMessage ? 'border-success focus-within:ring-success' : ''),\n      (function(schema){\n        function hasKey(obj, key){ return obj && Object.prototype.hasOwnProperty.call(obj, key); }\n        function isAttrTrue(obj, key){\n          if (!hasKey(obj, key)) return false;\n          var v = obj[key];\n          if (v === true || v === 1) return true;\n          if (typeof v === 'string'){\n            var s = v.trim().toLowerCase();\n            return s === '' || s === 'true' || s === '1' || s === 'on' || s === 'yes';\n          }\n          return false;\n        }\n        return (isAttrTrue(schema,'disabled') || isAttrTrue(schema,'isDisabled') || isAttrTrue(schema,'readOnly'))\n          ? 'opacity-50 cursor-not-allowed' : '';\n      })(schema)\n    ].join(' ')\"\n    :style=\"(function(){\n      var fw = schema.fullWidth===true || ['true','1','on','yes'].includes(((schema.fullWidth??'')+'').toLowerCase());\n      return fw ? {} : { minWidth: (schema.minWidth || '20ch') };\n    })()\"\n  >\n    <i v-if=\"schema.icon\" class=\"fa-regular text-[12px] text-muted-foreground\" :class=\"schema.icon\"></i>\n\n    <span v-if=\"schema.prefix\" class=\"text-sm text-muted-foreground\">{{ schema.prefix }}</span>\n\n    <input\n      :type=\"(schema.type || 'text')\"\n      :inputmode=\"(function(f){\n        if (f==='currency' || f==='number' || f==='percent') return 'decimal';\n        if (f==='integer' || f==='date' || f==='ssn') return 'numeric';\n        if (f==='phone') return 'tel';\n        return null;\n      })(schema.format)\"\n      class=\"flex-1 min-w-0 bg-transparent outline-none placeholder:text-muted-foreground text-foreground\"\n      :class=\"(\n        schema.size==='sm' ? 'text-sm' :\n        schema.size==='lg' ? 'text-base' :\n                             'text-sm'\n      )\"\n      :placeholder=\"schema.placeholder || ''\"\n      :maxlength=\"(schema.maxLength || null)\"\n      :required=\"!!schema.required\"\n      :disabled=\"(function(schema){\n        function hasKey(obj, key){ return obj && Object.prototype.hasOwnProperty.call(obj, key); }\n        function isAttrTrue(obj, key){\n          if (!hasKey(obj, key)) return false;\n          var v = obj[key];\n          if (v === true || v === 1) return true;\n          if (typeof v === 'string'){\n            var s = v.trim().toLowerCase();\n            return s === '' || s === 'true' || s === '1' || s === 'on' || s === 'yes';\n          }\n          return false;\n        }\n        return isAttrTrue(schema,'disabled') || isAttrTrue(schema,'isDisabled');\n      })(schema)\"\n      :readonly=\"(function(schema){\n        function hasKey(obj, key){ return obj && Object.prototype.hasOwnProperty.call(obj, key); }\n        function isAttrTrue(obj, key){\n          if (!hasKey(obj, key)) return false;\n          var v = obj[key];\n          if (v === true || v === 1) return true;\n          if (typeof v === 'string'){\n            var s = v.trim().toLowerCase();\n            return s === '' || s === 'true' || s === '1' || s === 'on' || s === 'yes';\n          }\n          return false;\n        }\n        return isAttrTrue(schema,'readOnly');\n      })(schema)\"\n\n      :value=\"(function(){\n        var win = vueapp.$store.state.wndw.windows[(schema.windowIndex ?? 0)];\n        var m   = win.formSchema.model || {};\n        var k   = schema.modelKey || 'inputValue';\n        function getByPath(obj, path){\n          if (!obj || !path) return '';\n          var p = String(path).replace(/\\[(\\w+)\\]/g, '.$1').replace(/^\\./,'').split('.');\n          var cur = obj;\n          for (var i=0; i<p.length; i++){ if (cur == null) return ''; cur = cur[p[i]]; }\n          return (cur == null ? '' : cur);\n        }\n        function groupInt(s){\n          s = (s||'').replace(/^0+(?=\\d)/,'');\n          return s.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',') || '0';\n        }\n        function fmtDecimalFromSan(clean, maxDec){\n          if (!clean) return '';\n          if (clean==='-') return '-';\n          var neg = clean[0]==='-';\n          var body = neg ? clean.slice(1) : clean;\n          var trailingDot = body.endsWith('.');\n          var parts = body.split('.');\n          var i = groupInt(parts[0]||'0');\n          var f = (parts[1]||'').slice(0, maxDec||2);\n          var out = i + (trailingDot ? '.' : (f ? ('.'+f) : ''));\n          return neg ? ('-'+out) : out;\n        }\n        function fmtIntegerFromSan(clean){\n          if (clean==='-') return '-';\n          if (!clean) return '';\n          var neg = clean[0]==='-';\n          var body = neg ? clean.slice(1) : clean;\n          var out = body.replace(/^0+(?=\\d)/,'').replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',') || '0';\n          return neg ? ('-'+out) : out;\n        }\n        function maskPhone(d){\n          if (!d) return '';\n          d = String(d).replace(/\\D/g,'').slice(0,10);\n          if (d.length <= 3) return d;\n          if (d.length <= 6) return '('+d.slice(0,3)+') '+d.slice(3);\n          return '('+d.slice(0,3)+') '+d.slice(3,6)+'-'+d.slice(6,10);\n        }\n        function maskDate(d){\n          if (!d) return '';\n          d = String(d).replace(/\\D/g,'').slice(0,8);\n          var mm = d.slice(0,2), dd = d.slice(2,4), yyyy = d.slice(4,8);\n          if (d.length <= 2) return mm;\n          if (d.length <= 4) return mm+'/'+dd;\n          return mm+'/'+dd+'/'+yyyy;\n        }\n        function maskSSN(d){\n          if (!d) return '';\n          d = String(d).replace(/\\D/g,'').slice(0,9);\n          if (d.length <= 3) return d;\n          if (d.length <= 5) return d.slice(0,3)+'-'+d.slice(3);\n          return d.slice(0,3)+'-'+d.slice(3,5)+'-'+d.slice(5,9);\n        }\n\n        var raw = getByPath(m, k);\n        var f   = schema.format;\n\n        if (f==='currency' || f==='number' || f==='percent'){\n          var s = String(raw==null?'':raw); if (s==='') return '';\n          var neg = s.trim().startsWith('-');\n          var digits = s.replace(/[^0-9.]/g,'');\n          var parts = digits.split('.');\n          var clean = (neg?'-':'') + (parts[0]||'0') + (parts.length>1?('.'+(parts[1]||'')):'');\n          return fmtDecimalFromSan(clean, 2);\n        } else if (f==='integer'){\n          var si = String(raw==null?'':raw); if (si==='') return '';\n          var negi = si.trim().startsWith('-');\n          var body = si.replace(/[^0-9]/g,'');\n          var cleanI = (negi && body==='' ? '-' : (negi?'-':'') + body);\n          return fmtIntegerFromSan(cleanI);\n        } else if (f==='phone'){\n          return maskPhone(raw);\n        } else if (f==='date'){\n          var r = String(raw==null?'':raw);\n          var iso = r.match(/^(\\d{4})-(\\d{2})-(\\d{2})$/);\n          if (iso) return iso[2]+'/'+iso[3]+'/'+iso[1];\n          return maskDate(r);\n        } else if (f==='ssn'){\n          return maskSSN(raw);\n        }\n        return raw;\n      })()\"\n\n      @input=\"(function($e){\n        var win = vueapp.$store.state.wndw.windows[(schema.windowIndex ?? 0)];\n        var m   = win.formSchema.model || {};\n        var k   = schema.modelKey || 'inputValue';\n        var el  = $e.target;\n        var val = el.value;\n        var f   = schema.format;\n        var data = $e.data;\n\n        function setByPath(obj, path, value){\n          var parts = String(path).replace(/\\[(\\w+)\\]/g, '.$1').replace(/^\\./,'').split('.');\n          var cur = obj;\n          for (var i=0; i<parts.length-1; i++){\n            var key = parts[i];\n            if (cur[key] == null){\n              if (typeof Vue !== 'undefined' && Vue.set) { Vue.set(cur, key, {}); }\n              else { cur[key] = {}; }\n            }\n            cur = cur[key];\n          }\n          var last = parts[parts.length-1];\n          if (typeof Vue !== 'undefined' && Vue.set) { Vue.set(cur, last, value); }\n          else { cur[last] = value; }\n        }\n\n        function countDigitsUpTo(str, pos){\n          var c=0; for (var i=0;i<Math.min(pos, str.length);i++){ if (/\\d/.test(str[i])) c++; } return c;\n        }\n        function caretFromDigitIndex(str, digitIndex){\n          if (digitIndex<=0) return 0;\n          var c=0;\n          for (var i=0;i<str.length;i++){\n            if (/\\d/.test(str[i])) c++;\n            if (c>=digitIndex) return i+1;\n          }\n          return str.length;\n        }\n\n        function sanitizeDecimal(s, maxDec, allowNeg){\n          s = (s==null?'':String(s));\n          var neg = !!allowNeg && s.trim().startsWith('-');\n          s = s.replace(/[^0-9.]/g,'');\n          if (s==='') return neg?'-':'';\n          var parts = s.split('.');\n          if (parts.length>2){ s = parts.shift()+'.'+parts.join(''); parts = s.split('.'); }\n          var intp = parts[0].replace(/^0+(?=\\d)/,''); if (intp==='') intp='0';\n          var frac = (parts[1]||'').slice(0,2);\n          var out  = intp + (parts.length>1?('.'+frac): (s.endsWith('.')?'.':''));\n          return neg ? ('-'+out.replace(/^\\-+/,'')) : out;\n        }\n        function sanitizeInteger(s, allowNeg){\n          s = (s==null?'':String(s));\n          var neg = !!allowNeg && s.trim().startsWith('-');\n          s = s.replace(/[^0-9]/g,'');\n          if (s==='') return neg?'-':'';\n          s = s.replace(/^0+(?=\\d)/,'');\n          return neg ? ('-'+s) : s;\n        }\n        function groupInt(s){\n          s = (s||'').replace(/^0+(?=\\d)/,'');\n          return s.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',') || '0';\n        }\n        function fmtDecimalFromSan(clean, maxDec){\n          if (!clean) return '';\n          if (clean==='-') return '-';\n          var neg = clean[0]==='-';\n          var body = neg ? clean.slice(1) : clean;\n          var trailingDot = body.endsWith('.');\n          var parts = body.split('.');\n          var i = groupInt(parts[0]||'0');\n          var f = (parts[1]||'').slice(0, maxDec||2);\n          var out = i + (trailingDot ? '.' : (f ? ('.'+f) : ''));\n          return neg ? ('-'+out) : out;\n        }\n        function fmtIntegerFromSan(clean){\n          if (clean==='-') return '-';\n          if (!clean) return '';\n          var neg = clean[0]==='-';\n          var body = neg ? clean.slice(1) : clean;\n          var out = body.replace(/^0+(?=\\d)/,'').replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',') || '0';\n          return neg ? ('-'+out) : out;\n        }\n        function maskPhone(d){\n          d = (d||'').toString().replace(/\\D/g,'').slice(0, schema.phoneMaxDigits||10);\n          if (d.length<=3) return d;\n          if (d.length<=6) return '('+d.slice(0,3)+') '+d.slice(3);\n          return '('+d.slice(0,3)+') '+d.slice(3,6)+'-'+d.slice(6,10);\n        }\n        function maskDate(d){\n          d = (d||'').toString().replace(/\\D/g,'').slice(0,8);\n          var mm = d.slice(0,2), dd = d.slice(2,4), yyyy = d.slice(4,8);\n          if (d.length<=2) return mm;\n          if (d.length<=4) return mm+'/'+dd;\n          return mm+'/'+dd+'/'+yyyy;\n        }\n        function maskSSN(d){\n          d = (d||'').toString().replace(/\\D/g,'').slice(0, schema.ssnMaxDigits||9);\n          if (d.length<=3) return d;\n          if (d.length<=5) return d.slice(0,3)+'-'+d.slice(3);\n          return d.slice(0,3)+'-'+d.slice(3,5)+'-'+d.slice(5,9);\n        }\n        function isoFromDigits(d){\n          d = (d||'').toString();\n          if (d.length!==8) return '';\n          var mm=d.slice(0,2), dd=d.slice(2,4), yyyy=d.slice(4,8);\n          var dt = new Date(Number(yyyy), Number(mm)-1, Number(dd));\n          if (dt && dt.getFullYear()==Number(yyyy) && (dt.getMonth()+1)==Number(mm) && dt.getDate()==Number(dd)){\n            return yyyy+'-'+mm+'-'+dd;\n          }\n          return '';\n        }\n        function toNumber(v){\n          if (v === '' || v == null || v==='-') return '';\n          var n = parseFloat(v);\n          return isNaN(n) ? '' : n;\n        }\n\n        var caret = el.selectionStart||0;\n        var digitIdx = countDigitsUpTo(val, caret);\n\n        if (f==='currency'){\n          var clean = sanitizeDecimal(val, 2, (schema.allowNegative !== false));\n          var display = fmtDecimalFromSan(clean, 2);\n          el.value = display;\n          var pos = caretFromDigitIndex(display, digitIdx);\n          if (data==='.' && display.indexOf('.')!==-1) pos = display.indexOf('.') + 1;\n          if (data==='-' && display[0]==='-') pos = Math.max(pos,1);\n          if (typeof el.setSelectionRange==='function'){ el.setSelectionRange(pos,pos); }\n          var n = toNumber(clean);\n          setByPath(m, k, (schema.storeAsNumber!==false) ? (n===''?'':n) : clean);\n\n        } else if (f==='number' || f==='percent'){\n          var cl = sanitizeDecimal(val, 2, (schema.allowNegative !== false));\n          var dis = fmtDecimalFromSan(cl, 2);\n          el.value = dis;\n          var pos2 = caretFromDigitIndex(dis, digitIdx);\n          if (data==='.' && dis.indexOf('.')!==-1) pos2 = dis.indexOf('.') + 1;\n          if (data==='-' && dis[0]==='-') pos2 = Math.max(pos2,1);\n          if (typeof el.setSelectionRange==='function'){ el.setSelectionRange(pos2,pos2); }\n          var nn = toNumber(cl);\n          setByPath(m, k, (schema.storeAsNumber===false) ? cl : (nn===''?'':nn));\n\n        } else if (f==='integer'){\n          var ci = sanitizeInteger(val, (schema.allowNegative !== false));\n          var di = fmtIntegerFromSan(ci);\n          el.value = di;\n          var pos3 = caretFromDigitIndex(di, digitIdx);\n          if (data==='-' && di[0]==='-') pos3 = Math.max(pos3,1);\n          if (typeof el.setSelectionRange==='function'){ el.setSelectionRange(pos3,pos3); }\n          setByPath(m, k, (schema.storeAsNumber===false) ? ci : (ci===''||ci==='-'? '' : parseInt(ci,10)));\n\n        } else if (f==='phone'){\n          var digits = (val||'').toString().replace(/\\D/g,'').slice(0, schema.phoneMaxDigits||10);\n          var masked = maskPhone(digits);\n          el.value = masked;\n          var pos4 = caretFromDigitIndex(masked, digitIdx);\n          if (typeof el.setSelectionRange==='function'){ el.setSelectionRange(pos4,pos4); }\n          setByPath(m, k, (schema.storeMasked===true) ? masked : digits);\n\n        } else if (f==='date'){\n          var d8 = (val||'').toString().replace(/\\D/g,'').slice(0,8);\n          var maskedD = maskDate(d8);\n          el.value = maskedD;\n          var pos5 = caretFromDigitIndex(maskedD, digitIdx);\n          if (typeof el.setSelectionRange==='function'){ el.setSelectionRange(pos5,pos5); }\n          var iso = isoFromDigits(d8);\n          setByPath(m, k, (iso && (schema.dateStoreISO !== false)) ? iso : d8);\n\n        } else if (f==='ssn'){\n          var d9 = (val||'').toString().replace(/\\D/g,'').slice(0, schema.ssnMaxDigits||9);\n          var maskedSSN = maskSSN(d9);\n          el.value = maskedSSN;\n          var posSSN = caretFromDigitIndex(maskedSSN, digitIdx);\n          if (typeof el.setSelectionRange==='function'){ el.setSelectionRange(posSSN,posSSN); }\n          setByPath(m, k, (schema.storeMasked===true) ? maskedSSN : d9);\n\n        } else {\n          setByPath(m, k, val);\n        }\n\n        var act = (schema.inputAction || '').toString().trim();\n        if (act) {\n          if (typeof BF !== 'undefined' && BF.namedAction) {\n            BF.namedAction(act, { value: el.value, event: $e });\n          } else if (typeof namedAction !== 'undefined') {\n            namedAction(act, { value: el.value, event: $e });\n          }\n        }\n      })($event)\"\n\n      @blur=\"(function($e){})($event)\"\n\n      @keydown.enter=\"(function(){\n        if(schema.namedAction){\n          if (typeof BF !== 'undefined' && BF.namedAction) {\n            BF.namedAction(schema.namedAction, schema.actionOptions||{});\n          } else if (typeof namedAction !== 'undefined') {\n            namedAction(schema.namedAction, schema.actionOptions||{});\n          }\n        }\n      })()\"\n      autocomplete=\"off\"\n    />\n\n    <span v-if=\"schema.suffix\" class=\"text-sm text-muted-foreground\">{{ schema.suffix }}</span>\n    <i v-if=\"schema.iconRight\" class=\"fa-regular text-[12px] text-muted-foreground\" :class=\"schema.iconRight\"></i>\n  </div>\n\n  <p v-if=\"schema.errorMessage\" class=\"mt-1 text-xs text-destructive\">{{ schema.errorMessage }}</p>\n  <p v-else-if=\"schema.successMessage\" class=\"mt-1 text-xs text-success\">{{ schema.successMessage }}</p>\n</div>",
    "icon": "",
    "iconRight": "",
    "inputAction": "",
    "isDisabled": false,
    "label": "",
    "maxLength": "",
    "modelKey": "",
    "onInput": "",
    "phoneMaxDigits": 10,
    "placeholder": "",
    "prefix": "",
    "readOnly": false,
    "required": false,
    "size": "md",
    "storeAsNumber": false,
    "successMessage": "",
    "suffix": "",
    "type": "text",
    "windowIndex": 0
}
```
</CodeGroup>

### How to Add This Component to Your BetterForms App

1. **Navigate to Components**: In your BetterForms site environment, click the **Components** tab in the left sidebar.

2. **Create New Component**: If the Input component is not already in your components list, click the **+New** button at the top left.

3. **Open Component Schema**: In the new component, click the **`</> Component Schema`** button to access the schema editor.

4. **Replace Schema Code**: Copy the complete schema from the **Component Schema** tab above and replace all the existing code in the Component Schema section.

5. **Open HTML Tab**: Click the **HTML** tab (located directly next to the Component Schema tab) to access the HTML editor.

6. **Replace HTML Code**: Copy the HTML template from the user-provided HTML and replace all the existing code in the HTML section.

   **Note**: This step might feel redundant since the HTML is included as a key/value in the component schema. However, this is sometimes a quirk in BetterForms, where the HTML doesn't render properly until you manually insert the HTML in the HTML tab on the new component.

7. **Save Component**: Click the **Save** button in the top right to save the component for use in your application.

8. **Refresh Pages**: **Important**: The component will not be available for use in any live pages you are currently viewing until you manually refresh the page using your browser's Refresh button. However, the component will be immediately available in the **Page Builder** section of every page after you save and navigate away from the Components section.

### Schema Properties Reference

- **`label`**: Text displayed above the input field
- **`placeholder`**: Placeholder text when input is empty
- **`type`**: HTML input type (text, email, password, etc.)
- **`format`**: Special formatting mode (currency, phone, date, ssn, integer, number, percent)
- **`modelKey`**: Model path where value is stored
- **`icon`**: Font Awesome icon on the left
- **`iconRight`**: Font Awesome icon on the right
- **`prefix`**: Text before input value
- **`suffix`**: Text after input value
- **`fullWidth`**: Whether input takes full container width
- **`size`**: Text size (sm, md, lg)
- **`required`**: Whether field is required
- **`readOnly`**: Whether input is read-only
- **`isDisabled`**: Whether input is disabled
- **`maxLength`**: Maximum character length
- **`allowNegative`**: Allow negative values for numeric formats
- **`storeAsNumber`**: Store numeric values as numbers instead of strings
- **`phoneMaxDigits`**: Maximum digits for phone format
- **`ssnMaxDigits`**: Maximum digits for SSN format
- **`storeMasked`**: Store masked value for phone/SSN
- **`dateStoreISO`**: Store dates in ISO format
- **`inputAction`**: Named action on input change
- **`namedAction`**: Named action on Enter key press
- **`errorMessage`**: Error message to display
- **`successMessage`**: Success message to display
- **`windowIndex`**: Window index for multi-window apps
