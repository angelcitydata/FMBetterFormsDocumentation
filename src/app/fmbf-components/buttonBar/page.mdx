export const metadata = {
  title: 'Button Bar Component',
  description:
    'A segmented control component for FM BetterForms that displays multiple options in a horizontal or vertical layout with customizable variants, full-width support, and keyboard navigation.',
}

# Button Bar Component

The Button Bar component provides a segmented control interface for selecting between multiple options in your FM BetterForms application. It features customizable variants (pill, solid, rounded, underline), horizontal or vertical orientation, full-width support, and comprehensive keyboard navigation for creating intuitive selection interfaces. {{ className: 'lead' }}

    This component supports multiple visual variants, optional icons for each option,
    disabled states, named actions on selection, and accessible keyboard navigation
    for creating tab-like interfaces and option selectors.

---

## Component Properties

### Content Properties

<Properties>
  <Property name="items" type="array">
    Array of objects defining the available options in the button bar. Each item
    should have a `label` (display text) and `value` (stored value). Optional
    properties include `icon` (Font Awesome class) and `disabled` (boolean).
    Example: `[{label: "Option 1", value: "opt1"}, {label: "Option 2", value: "opt2"}]`
  </Property>
  <Property name="modelKey" type="string">
    The model key where the selected value will be stored. This should match
    a property in your model object. Example: `"selectedOption"`, `"rangeChoice"`.
    Default is `"segValue"`.
  </Property>
  <Property name="variant" type="string">
    The visual style variant of the button bar. Controls the appearance and
    selection styling. Available variants: `"underline"`, `"pill"`, `"solid"`,
    `"rounded"`. Default is `"underline"`.
  </Property>
</Properties>

### Appearance Properties

<Properties>
  <Property name="orientation" type="string">
    The layout orientation of the button bar. When `"horizontal"`, buttons
    are arranged in a row. When `"vertical"`, buttons are stacked vertically.
    Default is `"horizontal"`.
  </Property>
  <Property name="fullWidth" type="boolean">
    Whether the button bar should expand to fill the full width of its container.
    When `true`, buttons will stretch evenly to fill the available space.
    Default is `false`.
  </Property>
  <Property name="schema" type="string">
    The color scheme for the component. Controls the active state colors.
    Available schemes: `"neutral"`, `"primary"`, `"secondary"`, `"destructive"`,
    `"success"`, `"warning"`, `"info"`. Default is `"neutral"`.
  </Property>
</Properties>

### Behavior Properties

<Properties>
  <Property name="onChange" type="string">
    The named action to trigger when a button is selected. The action will
    receive the selected value and index as parameters. Example: `"onOptionChange"`,
    `"updateSelection"`. Default is empty string.
  </Property>
  <Property name="windowIndex" type="number">
    Index of the window in the BetterForms window stack. Used for multi-window
    applications to access the correct model state. Default is 0.
  </Property>
</Properties>

---

## Button Bar Variants

The Button Bar component supports multiple visual variants that control the appearance and selection styling. Each variant provides a distinct look for different use cases and contexts.

### Available Variants

- **`underline`** - Text-based buttons with underline indicator for active state (default)
- **`pill`** - Rounded pill-shaped buttons with background highlight for active state
- **`solid`** - Solid background buttons with rounded corners
- **`rounded`** - Buttons with rounded corners and background highlight

### Variant Usage Guidelines

- Use **`underline`** for tab-like interfaces and subtle selection indicators
- Use **`pill`** for modern, mobile-friendly interfaces with clear selection states
- Use **`solid`** for prominent selection interfaces that need strong visual feedback
- Use **`rounded`** for balanced interfaces that need clear selection without being too bold

### Color Schemes

The component also supports different color schemes for the active state:

- **`neutral`** - Default scheme with background and border (default)
- **`primary`** - Primary brand colors
- **`secondary`** - Secondary/muted colors
- **`destructive`** - Red/danger colors for destructive actions
- **`success`** - Green colors for success states
- **`warning`** - Yellow/amber colors for warnings
- **`info`** - Blue colors for informational content

---

## Usage Examples

The Button Bar component is configured using JSON objects with properties for options, styling, and behavior. Here are common usage patterns for different scenarios.

### Basic Button Bar

<CodeGroup>
```html title="HTML Component"
<bfcomp name="ButtonBar" 
        items='[{"label": "Option 1", "value": "opt1"}, {"label": "Option 2", "value": "opt2"}]'
        modelKey="selectedOption">
</bfcomp>
```

```javascript title="Model Definition"
// Define button bar in your model
model.optionSelector = {
  items: [
    {label: "Option 1", value: "opt1"},
    {label: "Option 2", value: "opt2"}
  ],
  modelKey: "selectedOption"
}
```

```json title="JSON Configuration"
{
  "items": [
    {"label": "Option 1", "value": "opt1"},
    {"label": "Option 2", "value": "opt2"}
  ],
  "modelKey": "selectedOption"
}
```

</CodeGroup>

### Button Bar with Icons

<CodeGroup>
```html title="HTML Component"
<bfcomp name="ButtonBar" 
        items='[{"label": "Home", "value": "home", "icon": "fa-home"}, {"label": "Profile", "value": "profile", "icon": "fa-user"}]'
        variant="pill"
        modelKey="currentView">
</bfcomp>
```

```javascript title="Model Definition"
// Define button bar with icons in your model
model.navigationBar = {
  items: [
    {label: "Home", value: "home", icon: "fa-home"},
    {label: "Profile", value: "profile", icon: "fa-user"}
  ],
  variant: "pill",
  modelKey: "currentView"
}
```

```json title="JSON Configuration"
{
  "items": [
    {"label": "Home", "value": "home", "icon": "fa-home"},
    {"label": "Profile", "value": "profile", "icon": "fa-user"}
  ],
  "variant": "pill",
  "modelKey": "currentView"
}
```

</CodeGroup>

### Full-Width Button Bar

<CodeGroup>
```html title="HTML Component"
<bfcomp name="ButtonBar" 
        items='[{"label": "Small", "value": "small"}, {"label": "Medium", "value": "medium"}, {"label": "Large", "value": "large"}]'
        variant="solid"
        fullWidth="true"
        modelKey="size">
</bfcomp>
```

```javascript title="Model Definition"
// Define full-width button bar in your model
model.sizeSelector = {
  items: [
    {label: "Small", value: "small"},
    {label: "Medium", value: "medium"},
    {label: "Large", value: "large"}
  ],
  variant: "solid",
  fullWidth: true,
  modelKey: "size"
}
```

```json title="JSON Configuration"
{
  "items": [
    {"label": "Small", value: "small"},
    {"label": "Medium", value: "medium"},
    {"label": "Large", value: "large"}
  ],
  "variant": "solid",
  "fullWidth": true,
  "modelKey": "size"
}
```

</CodeGroup>

### Vertical Button Bar

<CodeGroup>
```html title="HTML Component"
<bfcomp name="ButtonBar" 
        items='[{"label": "Settings", "value": "settings"}, {"label": "Help", "value": "help"}, {"label": "About", "value": "about"}]'
        orientation="vertical"
        variant="rounded"
        modelKey="menuSelection">
</bfcomp>
```

```javascript title="Model Definition"
// Define vertical button bar in your model
model.sideMenu = {
  items: [
    {label: "Settings", value: "settings"},
    {label: "Help", value: "help"},
    {label: "About", value: "about"}
  ],
  orientation: "vertical",
  variant: "rounded",
  modelKey: "menuSelection"
}
```

```json title="JSON Configuration"
{
  "items": [
    {"label": "Settings", value: "settings"},
    {"label": "Help", value: "help"},
    {"label": "About", value: "about"}
  ],
  "orientation": "vertical",
  "variant": "rounded",
  "modelKey": "menuSelection"
}
```

</CodeGroup>

### Button Bar with Disabled Options

<CodeGroup>
```html title="HTML Component"
<bfcomp name="ButtonBar" 
        items='[{"label": "Active", "value": "active"}, {"label": "Disabled", "value": "disabled", "disabled": true}, {"label": "Another", "value": "another"}]'
        variant="pill"
        schema="primary"
        modelKey="status">
</bfcomp>
```

```javascript title="Model Definition"
// Define button bar with disabled options in your model
model.statusBar = {
  items: [
    {label: "Active", value: "active"},
    {label: "Disabled", value: "disabled", disabled: true},
    {label: "Another", value: "another"}
  ],
  variant: "pill",
  schema: "primary",
  modelKey: "status"
}
```

```json title="JSON Configuration"
{
  "items": [
    {"label": "Active", value: "active"},
    {"label": "Disabled", value: "disabled", "disabled": true},
    {"label": "Another", value: "another"}
  ],
  "variant": "pill",
  "schema": "primary",
  "modelKey": "status"
}
```

</CodeGroup>

### Button Bar with Change Handler

<CodeGroup>
```html title="HTML Component"
<bfcomp name="ButtonBar" 
        items='[{"label": "Tab 1", "value": "tab1"}, {"label": "Tab 2", "value": "tab2"}, {"label": "Tab 3", "value": "tab3"}]'
        variant="underline"
        onChange="onTabChange"
        modelKey="activeTab">
</bfcomp>
```

```javascript title="Model Definition"
// Define button bar with change handler in your model
model.tabBar = {
  items: [
    {label: "Tab 1", value: "tab1"},
    {label: "Tab 2", value: "tab2"},
    {label: "Tab 3", value: "tab3"}
  ],
  variant: "underline",
  onChange: "onTabChange",
  modelKey: "activeTab"
}
```

```json title="JSON Configuration"
{
  "items": [
    {"label": "Tab 1", value: "tab1"},
    {"label": "Tab 2", value: "tab2"},
    {"label": "Tab 3", value: "tab3"}
  ],
  "variant": "underline",
  "onChange": "onTabChange",
  "modelKey": "activeTab"
}
```

</CodeGroup>

---

## Component Schema

The complete component schema for the Button Bar component. Copy and paste this code into the Component Schema section of your BetterForms app.

### Complete Schema

<CodeGroup>
```json title="Component Schema"
{
    "fullWidth": "false",
    "html": "<!-- SEGMENTED CONTROL / BUTTON BAR -->\n<div\n  role=\"tablist\"\n  :aria-orientation=\"(schema.orientation==='vertical' ? 'vertical' : 'horizontal')\"\n  :class=\"(function(){\n    function truthy(v){ v=(v??'')+''; v=v.toLowerCase(); return (v==='true'||v==='1'||v==='on'||v==='yes'); }\n\n    var v = schema.variant || 'underline';\n    var r = schema.radius  || 'rounded-md';\n    var full = truthy(schema.fullWidth);\n\n    // use flex so width can expand; toggle w-full/w-fit\n    var base = (schema.orientation==='vertical' ? 'flex flex-col' : 'flex') + ' gap-1 ' + (full ? 'w-full' : 'w-fit');\n\n    if (v === 'pill')    return base + ' bg-muted/40 p-1 rounded-full';\n    if (v === 'solid')   return base + ' bg-muted/40 p-1 ' + r;\n    if (v === 'rounded') return base + ' bg-muted/40 p-1 ' + r;\n    return base; // underline\n  })()\"\n\n  @keydown.stop.prevent=\"(function(e){\n    var code  = e.key;\n    var raw   = schema.items;\n    var items;\n    try { items = Array.isArray(raw) ? raw : (typeof raw==='string' ? JSON.parse(raw) : []); } catch(_) { items = []; }\n    if (!items.length) return;\n\n    var win   = vueapp.$store.state.wndw.windows[schema.windowIndex];\n    var model = win.formSchema.model || {};\n    var k     = schema.modelKey || 'segValue';\n\n    function isDisabled(it){\n      var d = it && it.disabled;\n      if (d === true) return true;\n      var s = ((d ?? '') + '').toLowerCase();\n      return ['true','1','on','yes'].includes(s);\n    }\n\n    var idx = Math.max(0, items.findIndex(function(it){ return it && it.value === model[k]; }));\n    var horiz = (schema.orientation!=='vertical');\n\n    function nextIndex(dir){\n      var i = idx;\n      for (var tries=0; tries<items.length; tries++){\n        i = (i + dir + items.length) % items.length;\n        if (!isDisabled(items[i])) return i;\n      }\n      return idx;\n    }\n\n    if ((horiz && code==='ArrowRight') || (!horiz && code==='ArrowDown')) { var ni = nextIndex(+1); model[k] = items[ni]?.value; return; }\n    if ((horiz && code==='ArrowLeft')  || (!horiz && code==='ArrowUp'))   { var pi = nextIndex(-1); model[k] = items[pi]?.value; return; }\n    if (code==='Home'){ var f = items.find(function(it){ return it && !isDisabled(it); }); if (f) model[k]=f.value; return; }\n    if (code==='End'){ for (var j=items.length-1;j>=0;j--){ if(!isDisabled(items[j])){ model[k]=items[j].value; break; } } return; }\n  })(event)\"\n>\n  <!-- Segment -->\n  <button\n    v-for=\"(opt, i) in (function(){\n      try { return Array.isArray(schema.items) ? schema.items : (typeof schema.items==='string' ? JSON.parse(schema.items) : []); }\n      catch(_) { return []; }\n    })()\"\n    :key=\"opt.value || i\"\n    type=\"button\"\n    role=\"tab\"\n    :disabled=\"(function(v){ v=(v??'')+''; v=v.toLowerCase(); return (opt.disabled===true)||['true','1','on','yes'].includes(v); })(opt.disabled)\"\n    :aria-selected=\"(function(){\n      var m = vueapp.$store.state.wndw.windows[schema.windowIndex].formSchema.model || {};\n      return (m[schema.modelKey||'segValue'] === opt.value) ? 'true' : 'false';\n    })()\"\n    :tabindex=\"(function(){\n      var m = vueapp.$store.state.wndw.windows[schema.windowIndex].formSchema.model || {};\n      return (m[schema.modelKey||'segValue'] === opt.value) ? 0 : -1;\n    })()\"\n    @click=\"(function(){\n      if ((function(v){ v=(v??'')+''; v=v.toLowerCase(); return (opt.disabled===true)||['true','1','on','yes'].includes(v); })(opt.disabled)) return;\n      var win = vueapp.$store.state.wndw.windows[schema.windowIndex];\n      var m   = win.formSchema.model || {};\n      var k   = schema.modelKey || 'segValue';\n      m[k]    = opt.value;\n      if (schema.onChange) { namedAction(schema.onChange, { value: opt.value, index: i }); }\n    })()\"\n\n    :class=\"(function(){\n      function truthy(v){ v=(v??'')+''; v=v.toLowerCase(); return (v==='true'||v==='1'||v==='on'||v==='yes'); }\n\n      var m   = vueapp.$store.state.wndw.windows[schema.windowIndex].formSchema.model || {};\n      var on  = (m[schema.modelKey||'segValue'] === opt.value);\n      var v   = schema.variant || 'underline';\n      var r   = schema.radius  || 'rounded-md';\n      var s   = (schema.scheme || 'neutral').toLowerCase();\n      var grow = truthy(schema.fullWidth);\n\n      // shape helpers\n      var shape = (v === 'pill') ? 'rounded-full' : r;\n\n      // color helpers for ACTIVE chip\n      function activeByScheme(sc){\n        switch(sc){\n          case 'primary':     return 'bg-primary text-primary-foreground';\n          case 'secondary':   return 'bg-secondary text-secondary-foreground';\n          case 'destructive': return 'bg-destructive text-destructive-foreground';\n          case 'success':     return 'bg-success text-foreground';\n          case 'warning':     return 'bg-warning text-foreground';\n          case 'info':        return 'bg-info text-foreground';\n          case 'neutral':\n          default:            return 'bg-background text-foreground border border-input shadow-sm';\n        }\n      }\n      // underline color per scheme\n      function underlineByScheme(sc){\n        switch(sc){\n          case 'secondary':   return 'after:bg-secondary';\n          case 'destructive': return 'after:bg-destructive';\n          case 'success':     return 'after:bg-success';\n          case 'warning':     return 'after:bg-warning';\n          case 'info':        return 'after:bg-info';\n          case 'neutral':     return 'after:bg-primary';\n          case 'primary':\n          default:            return 'after:bg-primary';\n        }\n      }\n\n      var base = [\n        'relative inline-flex items-center justify-center text-sm font-medium transition-colors',\n        'focus:outline-none disabled:opacity-50 disabled:pointer-events-none',\n        (schema.orientation==='vertical' ? 'px-3 py-2' : 'px-4 py-2'),\n        (grow ? 'flex-1 min-w-0' : '') // stretch evenly if fullWidth\n      ].join(' ');\n\n      // variant-specific composition\n      if (v === 'solid' || v === 'pill' || v === 'rounded') {\n        return base + ' ' + (on\n          ? (activeByScheme(s) + ' ' + shape)\n          : ('text-muted-foreground hover:text-foreground ' + shape));\n      }\n\n      // underline (default)\n      return base + ' ' + (on\n        ? ('text-foreground after:absolute after:left-0 after:-bottom-[1px] after:h-0.5 after:w-full after:content-[\\'\\'] ' + underlineByScheme(s))\n        : 'text-muted-foreground hover:text-foreground');\n    })()\"\n  >\n    <i v-if=\"opt.icon\" class=\"fa-regular text-[12px] mr-1\" :class=\"opt.icon\"></i>\n    <span>{{ opt.label || opt.value || ('Option ' + (i+1)) }}</span>\n  </button>\n</div>",
    "items": [],
    "modelKey": "rangeChoice",
    "onChange": "",
    "orientation": "horizontal",
    "schema": "neutral",
    "variant": "pill",
    "windowIndex": 0
}
```

```html title="HTML Template"
<!-- SEGMENTED CONTROL / BUTTON BAR -->
<div
  role="tablist"
  :aria-orientation="(schema.orientation==='vertical' ? 'vertical' : 'horizontal')"
  :class="(function(){
    function truthy(v){ v=(v??'')+''; v=v.toLowerCase(); return (v==='true'||v==='1'||v==='on'||v==='yes'); }

    var v = schema.variant || 'underline';
    var r = schema.radius  || 'rounded-md';
    var full = truthy(schema.fullWidth);

    // use flex so width can expand; toggle w-full/w-fit
    var base = (schema.orientation==='vertical' ? 'flex flex-col' : 'flex') + ' gap-1 ' + (full ? 'w-full' : 'w-fit');

    if (v === 'pill')    return base + ' bg-muted/40 p-1 rounded-full';
    if (v === 'solid')   return base + ' bg-muted/40 p-1 ' + r;
    if (v === 'rounded') return base + ' bg-muted/40 p-1 ' + r;
    return base; // underline
  })()"

  @keydown.stop.prevent="(function(e){
    var code  = e.key;
    var raw   = schema.items;
    var items;
    try { items = Array.isArray(raw) ? raw : (typeof raw==='string' ? JSON.parse(raw) : []); } catch(_) { items = []; }
    if (!items.length) return;

    var win   = vueapp.$store.state.wndw.windows[schema.windowIndex];
    var model = win.formSchema.model || {};
    var k     = schema.modelKey || 'segValue';

    function isDisabled(it){
      var d = it && it.disabled;
      if (d === true) return true;
      var s = ((d ?? '') + '').toLowerCase();
      return ['true','1','on','yes'].includes(s);
    }

    var idx = Math.max(0, items.findIndex(function(it){ return it && it.value === model[k]; }));
    var horiz = (schema.orientation!=='vertical');

    function nextIndex(dir){
      var i = idx;
      for (var tries=0; tries<items.length; tries++){
        i = (i + dir + items.length) % items.length;
        if (!isDisabled(items[i])) return i;
      }
      return idx;
    }

    if ((horiz && code==='ArrowRight') || (!horiz && code==='ArrowDown')) { var ni = nextIndex(+1); model[k] = items[ni]?.value; return; }
    if ((horiz && code==='ArrowLeft')  || (!horiz && code==='ArrowUp'))   { var pi = nextIndex(-1); model[k] = items[pi]?.value; return; }
    if (code==='Home'){ var f = items.find(function(it){ return it && !isDisabled(it); }); if (f) model[k]=f.value; return; }
    if (code==='End'){ for (var j=items.length-1;j>=0;j--){ if(!isDisabled(items[j])){ model[k]=items[j].value; break; } } return; }
  })(event)"
>
  <!-- Segment -->
  <button
    v-for="(opt, i) in (function(){
      try { return Array.isArray(schema.items) ? schema.items : (typeof schema.items==='string' ? JSON.parse(schema.items) : []); }
      catch(_) { return []; }
    })()"
    :key="opt.value || i"
    type="button"
    role="tab"
    :disabled="(function(v){ v=(v??'')+''; v=v.toLowerCase(); return (opt.disabled===true)||['true','1','on','yes'].includes(v); })(opt.disabled)"
    :aria-selected="(function(){
      var m = vueapp.$store.state.wndw.windows[schema.windowIndex].formSchema.model || {};
      return (m[schema.modelKey||'segValue'] === opt.value) ? 'true' : 'false';
    })()"
    :tabindex="(function(){
      var m = vueapp.$store.state.wndw.windows[schema.windowIndex].formSchema.model || {};
      return (m[schema.modelKey||'segValue'] === opt.value) ? 0 : -1;
    })()"
    @click="(function(){
      if ((function(v){ v=(v??'')+''; v=v.toLowerCase(); return (opt.disabled===true)||['true','1','on','yes'].includes(v); })(opt.disabled)) return;
      var win = vueapp.$store.state.wndw.windows[schema.windowIndex];
      var m   = win.formSchema.model || {};
      var k   = schema.modelKey || 'segValue';
      m[k]    = opt.value;
      if (schema.onChange) { namedAction(schema.onChange, { value: opt.value, index: i }); }
    })()"

    :class="(function(){
      function truthy(v){ v=(v??'')+''; v=v.toLowerCase(); return (v==='true'||v==='1'||v==='on'||v==='yes'); }

      var m   = vueapp.$store.state.wndw.windows[schema.windowIndex].formSchema.model || {};
      var on  = (m[schema.modelKey||'segValue'] === opt.value);
      var v   = schema.variant || 'underline';
      var r   = schema.radius  || 'rounded-md';
      var s   = (schema.scheme || 'neutral').toLowerCase();
      var grow = truthy(schema.fullWidth);

      // shape helpers
      var shape = (v === 'pill') ? 'rounded-full' : r;

      // color helpers for ACTIVE chip
      function activeByScheme(sc){
        switch(sc){
          case 'primary':     return 'bg-primary text-primary-foreground';
          case 'secondary':   return 'bg-secondary text-secondary-foreground';
          case 'destructive': return 'bg-destructive text-destructive-foreground';
          case 'success':     return 'bg-success text-foreground';
          case 'warning':     return 'bg-warning text-foreground';
          case 'info':        return 'bg-info text-foreground';
          case 'neutral':
          default:            return 'bg-background text-foreground border border-input shadow-sm';
        }
      }
      // underline color per scheme
      function underlineByScheme(sc){
        switch(sc){
          case 'secondary':   return 'after:bg-secondary';
          case 'destructive': return 'after:bg-destructive';
          case 'success':     return 'after:bg-success';
          case 'warning':     return 'after:bg-warning';
          case 'info':        return 'after:bg-info';
          case 'neutral':     return 'after:bg-primary';
          case 'primary':
          default:            return 'after:bg-primary';
        }
      }

      var base = [
        'relative inline-flex items-center justify-center text-sm font-medium transition-colors',
        'focus:outline-none disabled:opacity-50 disabled:pointer-events-none',
        (schema.orientation==='vertical' ? 'px-3 py-2' : 'px-4 py-2'),
        (grow ? 'flex-1 min-w-0' : '') // stretch evenly if fullWidth
      ].join(' ');

      // variant-specific composition
      if (v === 'solid' || v === 'pill' || v === 'rounded') {
        return base + ' ' + (on
          ? (activeByScheme(s) + ' ' + shape)
          : ('text-muted-foreground hover:text-foreground ' + shape));
      }

      // underline (default)
      return base + ' ' + (on
        ? ('text-foreground after:absolute after:left-0 after:-bottom-[1px] after:h-0.5 after:w-full after:content-[\'\'] ' + underlineByScheme(s))
        : 'text-muted-foreground hover:text-foreground');
    })()"
  >
    <i v-if="opt.icon" class="fa-regular text-[12px] mr-1" :class="opt.icon"></i>
    <span>{{ opt.label || opt.value || ('Option ' + (i+1)) }}</span>
  </button>
</div>
```
</CodeGroup>

### How to Add This Component to Your BetterForms App

1. **Navigate to Components**: In your BetterForms site environment, click the **Components** tab in the left sidebar.

2. **Create New Component**: If the Button Bar component is not already in your components list, click the **+New** button at the top left.

3. **Open Component Schema**: In the new component, click the **`</> Component Schema`** button to access the schema editor.

4. **Replace Schema Code**: Copy the complete schema from the **Component Schema** tab above and replace all the existing code in the Component Schema section.

5. **Open HTML Tab**: Click the **HTML** tab (located directly next to the Component Schema tab) to access the HTML editor.

6. **Replace HTML Code**: Copy the HTML template from the **HTML Template** tab above and replace all the existing code in the HTML section.

   **Note**: This step might feel redundant since the HTML is included as a key/value in the component schema. However, this is sometimes a quirk in BetterForms, where the HTML doesn't render properly until you manually insert the HTML in the HTML tab on the new component.

7. **Save Component**: Click the **Save** button in the top right to save the component for use in your application.

8. **Refresh Pages**: **Important**: The component will not be available for use in any live pages you are currently viewing until you manually refresh the page using your browser's Refresh button. However, the component will be immediately available in the **Page Builder** section of every page after you save and navigate away from the Components section.

### Schema Properties Reference

- **`items`**: Array of option objects with `label`, `value`, optional `icon` and `disabled`
- **`modelKey`**: Model key where selected value is stored
- **`variant`**: Visual style variant (underline, pill, solid, rounded)
- **`orientation`**: Layout orientation (horizontal, vertical)
- **`fullWidth`**: Whether buttons expand to fill container width
- **`schema`**: Color scheme for active state (neutral, primary, secondary, destructive, success, warning, info)
- **`onChange`**: Named action to trigger on selection change
- **`windowIndex`**: Window index for multi-window applications (default: 0)

---

## Button Bar Styling

The Button Bar component features a flexible, accessible design with consistent spacing and clear visual hierarchy. The styling provides excellent usability and maintains a clean appearance for option selection interfaces.

### Visual Structure

The button bar renders with the following structure:

- **Container**: Flex container with gap spacing, background, padding, and rounded corners
- **Buttons**: Individual button elements with role="tab" for accessibility
- **Icons**: Optional Font Awesome icons with regular weight
- **Labels**: Text content with medium font weight

### Default Appearance (Underline Variant)

```html
<!-- Button Bar Structure -->
<div role="tablist" aria-orientation="horizontal" class="flex gap-1 w-fit">
  <!-- Button -->
  <button
    type="button"
    role="tab"
    aria-selected="true"
    tabindex="0"
    class="relative inline-flex items-center justify-center text-sm font-medium transition-colors focus:outline-none disabled:opacity-50 disabled:pointer-events-none px-4 py-2 text-foreground after:absolute after:left-0 after:-bottom-[1px] after:h-0.5 after:w-full after:content-[''] after:bg-primary"
  >
    <!-- Icon -->
    <i class="fa-regular text-[12px] mr-1 fa-home"></i>
    
    <!-- Label -->
    <span>Home</span>
  </button>
</div>
```

### Variant Styling

Each variant applies different container and button styling:

**Underline (default)**:
```html
<!-- Container -->
<div class="flex gap-1 w-fit">

<!-- Active Button -->
<button class="text-foreground after:absolute after:left-0 after:-bottom-[1px] after:h-0.5 after:w-full after:content-[''] after:bg-primary">Button</button>

<!-- Inactive Button -->
<button class="text-muted-foreground hover:text-foreground">Button</button>
</div>
```

**Pill Variant**:
```html
<!-- Container -->
<div class="flex gap-1 bg-muted/40 p-1 rounded-full w-fit">

<!-- Active Button -->
<button class="bg-background text-foreground border border-input shadow-sm rounded-full">Button</button>

<!-- Inactive Button -->
<button class="text-muted-foreground hover:text-foreground rounded-full">Button</button>
</div>
```

**Solid Variant**:
```html
<!-- Container -->
<div class="flex gap-1 bg-muted/40 p-1 rounded-md w-fit">

<!-- Active Button -->
<button class="bg-background text-foreground border border-input shadow-sm rounded-md">Button</button>

<!-- Inactive Button -->
<button class="text-muted-foreground hover:text-foreground rounded-md">Button</button>
</div>
```

**Rounded Variant**:
```html
<!-- Container -->
<div class="flex gap-1 bg-muted/40 p-1 rounded-md w-fit">

<!-- Active Button -->
<button class="bg-background text-foreground border border-input shadow-sm rounded-md">Button</button>

<!-- Inactive Button -->
<button class="text-muted-foreground hover:text-foreground rounded-md">Button</button>
</div>
```

### Color Schemes

Each color scheme applies different active state colors:

```html
<!-- Neutral Scheme (default) -->
<button class="bg-background text-foreground border border-input shadow-sm">Button</button>

<!-- Primary Scheme -->
<button class="bg-primary text-primary-foreground">Button</button>

<!-- Secondary Scheme -->
<button class="bg-secondary text-secondary-foreground">Button</button>

<!-- Destructive Scheme -->
<button class="bg-destructive text-destructive-foreground">Button</button>

<!-- Success Scheme -->
<button class="bg-success text-foreground">Button</button>

<!-- Warning Scheme -->
<button class="bg-warning text-foreground">Button</button>

<!-- Info Scheme -->
<button class="bg-info text-foreground">Button</button>
```

### Orientation Variations

**Horizontal (default)**:
```html
<div class="flex gap-1">
  <button class="px-4 py-2">Button 1</button>
  <button class="px-4 py-2">Button 2</button>
</div>
```

**Vertical**:
```html
<div class="flex flex-col gap-1">
  <button class="px-3 py-2">Button 1</button>
  <button class="px-3 py-2">Button 2</button>
</div>
```

### Full-Width Styling

When `fullWidth` is true, buttons stretch to fill available space:

```html
<div class="flex gap-1 w-full">
  <button class="flex-1 min-w-0 px-4 py-2">Button 1</button>
  <button class="flex-1 min-w-0 px-4 py-2">Button 2</button>
</div>
```

### Icon Styling

Icons use Font Awesome with regular weight and small size:

```html
<!-- Button with Icon -->
<button class="relative inline-flex items-center justify-center text-sm font-medium px-4 py-2">
  <i class="fa-regular text-[12px] mr-1 fa-home"></i>
  <span>Home</span>
</button>
```

### Accessibility Features

The component includes comprehensive accessibility support:

- **Semantic HTML** - Uses `<div role="tablist">` and `<button role="tab">`
- **ARIA Attributes** - `aria-orientation`, `aria-selected`, `tabindex`
- **Keyboard Navigation** - Arrow keys, Home, End for navigation
- **Focus Management** - Only active tab is focusable (`tabindex="0"`)
- **Screen Reader Support** - Proper roles and states for assistive technologies

### Keyboard Navigation

The component supports full keyboard navigation:

- **Arrow Keys** - Navigate between options (Left/Right for horizontal, Up/Down for vertical)
- **Home** - Jump to first enabled option
- **End** - Jump to last enabled option
- **Tab** - Move focus to/from the component
- **Enter/Space** - Activate selected option

### Theme Integration

The component uses CSS custom properties for colors:

- `bg-muted/40` - Container background
- `text-foreground`, `text-muted-foreground` - Text colors
- `bg-background`, `border-input` - Active state colors
- `transition-colors` - Smooth color transitions
- `focus:outline-none` - Custom focus styling

---

## Best Practices

When using the Button Bar component, follow these guidelines for optimal user experience and consistent design.

### Content Guidelines

**✅ Do:**

- Keep button labels concise and descriptive (1-3 words)
- Use consistent terminology across your application
- Choose appropriate variants that match the interface context
- Use icons that enhance understanding of the button purpose
- Limit the number of options to avoid overwhelming users (3-7 options recommended)

**❌ Don't:**

- Use overly long text that breaks the button layout
- Mix different terminology for similar actions
- Use variants that don't match the interface context
- Overuse icons or use irrelevant icons
- Create button bars with too many options that become difficult to navigate

### Variant Selection

**Interface Types:**
- `underline` - Tab interfaces, navigation menus, subtle selection
- `pill` - Modern interfaces, mobile-friendly, clear selection states
- `solid` - Prominent selection interfaces, strong visual feedback
- `rounded` - Balanced interfaces, clear selection without being too bold

**Color Schemes:**
- `neutral` - Default scheme, general purpose interfaces
- `primary` - High importance, featured content selection
- `secondary` - Medium importance, standard content selection
- `destructive` - Destructive actions, warning states
- `success` - Success states, positive actions
- `warning` - Warning states, attention-required actions
- `info` - Informational content, tips and guidance

### Accessibility Considerations

**✅ Do:**

- Ensure sufficient color contrast between text and background
- Test with screen readers to ensure proper reading order
- Provide clear, descriptive labels for all buttons
- Test keyboard navigation thoroughly
- Use appropriate ARIA roles and attributes

**❌ Don't:**

- Rely solely on color to convey information
- Create buttons that are too small to interact with on mobile devices
- Forget to test keyboard navigation
- Use disabled options without providing alternative ways to access the information
- Overload the interface with too many options

### Layout Guidelines

**✅ Do:**

- Use horizontal orientation for most interfaces (default)
- Use vertical orientation for sidebars and narrow spaces
- Consider full-width layout for equal importance options
- Maintain consistent spacing between buttons
- Align button bars with other interface elements

**❌ Don't:**

- Mix orientations within the same interface
- Create button bars that break on smaller screens
- Use inconsistent spacing or alignment
- Place button bars in locations that are difficult to access

### Performance Tips

**✅ Do:**

- Use button bars for static or semi-static option sets
- Implement efficient named actions for change handlers
- Consider the total number of button bars on a page for performance
- Use appropriate model keys to avoid conflicts

**❌ Don't:**

- Use button bars for frequently changing content without proper state management
- Create button bars without implementing the corresponding named actions
- Overload pages with too many button bars that impact rendering performance
- Use generic model keys that might conflict with other components
